import os
import shutil
import subprocess
import json
import logging
from typing import Optional
from pathlib import Path
from fastapi import FastAPI, UploadFile, File, Form, BackgroundTasks, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import FileResponse
from mutagen.mp3 import MP3
from mutagen.id3 import ID3

# Configuration
BASE_DIR = Path(__file__).parent
BIN_DIR = BASE_DIR / "bin"
TEMP_DIR = BASE_DIR / "temp"
OUTPUT_DIR = BASE_DIR / "output"
FONT_PATH = BIN_DIR / "font.ttf"
FFMPEG_BINARY = BIN_DIR / "ffmpeg"

# Ensure directories exist
TEMP_DIR.mkdir(exist_ok=True)
OUTPUT_DIR.mkdir(exist_ok=True)

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

def get_audio_duration(file_path: Path) -> float:
    try:
        audio = MP3(file_path)
        return audio.info.length
    except Exception as e:
        logger.error(f"Error reading audio duration: {e}")
        # Fallback using ffprobe if mutagen fails or not MP3
        return 0.0

def get_metadata(file_path: Path):
    title = "Unknown Track"
    artist = "Never Ending Loop" # Default/Fixed as requested
    try:
        audio = ID3(file_path)
        if "TIT2" in audio:
            title = str(audio["TIT2"].text[0])
    except Exception:
        pass
    return title, artist

@app.post("/render")
async def render_video(
    background_file: UploadFile = File(...),
    audio_file: UploadFile = File(...),
    visualizer_type: str = Form("spectrum"), # spectrum, wave, circle
    text_color: str = Form("white"),
    bar_color: str = Form("white"),
    title: str = Form(None),
    artist: str = Form(None),
    resolution: str = Form("1920x1080"),
    text_position: str = Form("center"), # center, top, bottom, top_left, top_right, bottom_left, bottom_right
    fade_in: float = Form(0.0), # seconds
    fade_out: float = Form(0.0), # seconds
    preview_mode: bool = Form(False)
):
    # Save Uploaded Files
    audio_path = TEMP_DIR / audio_file.filename
    bg_path = TEMP_DIR / background_file.filename
    
    with open(audio_path, "wb") as f:
        shutil.copyfileobj(audio_file.file, f)
    with open(bg_path, "wb") as f:
        shutil.copyfileobj(background_file.file, f)
        
    # Metadata & Duration
    duration = get_audio_duration(audio_path)
    
    # Use provided title/artist or fallback to metadata
    meta_title, meta_artist = get_metadata(audio_path)
    final_title = title if title else meta_title
    final_artist = artist if artist else meta_artist
    
    # Parse Resolution
    try:
        w_str, h_str = resolution.lower().split("x")
        w = int(w_str)
        h = int(h_str)
    except ValueError:
        w, h = 1920, 1080
    
    # Output Filename
    output_filename = f"render_{audio_file.filename}_{'preview' if preview_mode else 'full'}.mp4"
    output_path = OUTPUT_DIR / output_filename

    # FFmpeg Command Construction
    # We will use the static binary we downloaded
    ffmpeg_cmd = [str(FFMPEG_BINARY), "-y"]
    
    # Inputs
    ffmpeg_cmd.extend(["-stream_loop", "-1", "-i", str(bg_path)]) # Loop background
    ffmpeg_cmd.extend(["-i", str(audio_path)]) # Audio
    
    # Filter Complex
    # 1. Scale/Crop Background
    # 2. Visualizer generation
    # 3. Overlay visualizer on background
    # 4. Draw Text
    
    # Background Scaling
    bg_scale_filter = f"[0:v]scale={w}:{h}:force_original_aspect_ratio=increase,crop={w}:{h}[bg_scaled]"
    
    # Define visualizer filter
    if visualizer_type == "wave":
        viz_height = int(h * 0.2)
        viz_filter = f"[1:a]showwaves=s={w}x{viz_height}:mode=line:colors={formatted_bar_color}[viz]"
        overlay_cmd = f"[bg_scaled][viz]overlay=0:H-{viz_height}[bg_viz]"
    elif visualizer_type == "wave_center": # New: Centered Wave
        viz_height = int(h * 0.3)
        viz_filter = f"[1:a]showwaves=s={w}x{viz_height}:mode=cline:colors={formatted_bar_color}[viz]"
        overlay_cmd = f"[bg_scaled][viz]overlay=0:(H-h)/2[bg_viz]"
    elif visualizer_type == "circle":
        # Temporarily use showwaves instead of showcqt to avoid potential parsing issues
        viz_height = int(h * 0.3)
        viz_filter = f"[1:a]showwaves=s={w}x{viz_height}:mode=line:colors={formatted_bar_color}[viz]"
        overlay_cmd = f"[bg_scaled][viz]overlay=(W-w)/2:(H-h)/2[bg_viz]"
    elif visualizer_type == "ave": # Lissajous (Keyed out black)
        viz_filter = f"[1:a]avectorscope=s={w}x{h}:m=lissajous:draw=line:rc=255:gc=255:bc=255:ac=255[viz_raw];[viz_raw]colorkey=0x000000:0.1:0.1[viz]"
        overlay_cmd = f"[bg_scaled][viz]overlay=0:0[bg_viz]"
    elif visualizer_type == "spectrogram": # Scrolling Fire
        viz_height = int(h * 0.4)
        viz_filter = f"[1:a]showspectrum=s={w}x{viz_height}:mode=combined:color=fire:slide=scroll:scale=log[viz_raw];[viz_raw]colorkey=0x000000:0.1:0.1[viz]"
        overlay_cmd = f"[bg_scaled][viz]overlay=0:H-{viz_height}[bg_viz]"
    else: # Spectrum (Default)
        # Temporarily use showwaves instead of showcqt to avoid potential parsing issues
        viz_height = int(h * 0.3)
        viz_filter = f"[1:a]showwaves=s={w}x{viz_height}:mode=line:colors={formatted_bar_color}[viz]"
        overlay_cmd = f"[bg_scaled][viz]overlay=0:H-{viz_height}[bg_viz]"

    # Text Draw (Title + Artist)
    font_file = str(FONT_PATH).replace("\\", "/")

    def escape_text(text):
        if not text:
            return ""
        return text.replace(":", "\\:").replace("'", "\\'")

    # Escape colors to ensure they're properly formatted for FFmpeg
    def format_color(color):
        # Remove hash if present and ensure it's properly formatted
        if color.startswith('#'):
            return color[1:]  # Remove the '#' prefix
        return color

    safe_title = escape_text(final_title)
    safe_artist = escape_text(final_artist)
    formatted_text_color = format_color(text_color)
    formatted_bar_color = format_color(bar_color)

    # Scale font size relative to height (baseline 1080p)
    font_scale = h / 1080.0
    title_size = int(64 * font_scale)
    artist_size = int(48 * font_scale)
    spacing = int(80 * font_scale)

    # Calculate X/Y based on position preset
    # Default Center
    x_title = "(w-text_w)/2"
    y_title = f"(h/2)-{int(50*font_scale)}"
    x_artist = "(w-text_w)/2"
    y_artist = f"(h/2)+{int(30*font_scale)}"

    align_x = "(w-text_w)/2" # Default center align

    if text_position == "bottom":
        y_title = f"h-{int(150*font_scale)}"
        y_artist = f"h-{int(80*font_scale)}"
    elif text_position == "top":
        y_title = f"{int(80*font_scale)}"
        y_artist = f"{int(150*font_scale)}"
    elif "left" in text_position:
        align_x = f"{int(50*font_scale)}" # Left padding
        x_title = align_x
        x_artist = align_x
        if "top" in text_position:
            y_title = f"{int(80*font_scale)}"
            y_artist = f"{int(150*font_scale)}"
        elif "bottom" in text_position:
            y_title = f"h-{int(150*font_scale)}"
            y_artist = f"h-{int(80*font_scale)}"
    elif "right" in text_position:
        align_x = f"w-text_w-{int(50*font_scale)}" # Right padding
        x_title = align_x
        x_artist = align_x
        if "top" in text_position:
            y_title = f"{int(80*font_scale)}"
            y_artist = f"{int(150*font_scale)}"
        elif "bottom" in text_position:
            y_title = f"h-{int(150*font_scale)}"
            y_artist = f"h-{int(80*font_scale)}"

    text_filter = (
        f"[bg_viz]drawtext=fontfile='{font_file}':text='{safe_title}':fontsize={title_size}:fontcolor={formatted_text_color}:x={x_title}:y={y_title}:shadowcolor=black:shadowx=2:shadowy=2[txt1];"
        f"[txt1]drawtext=fontfile='{font_file}':text='{safe_artist}':fontsize={artist_size}:fontcolor={formatted_text_color}:x={x_artist}:y={y_artist}:shadowcolor=black:shadowx=2:shadowy=2[outv]"
    )
    
    full_filter = bg_scale_filter + ";" + viz_filter + ";" + overlay_cmd + ";" + text_filter
    
    ffmpeg_cmd.extend(["-filter_complex", full_filter])
    ffmpeg_cmd.extend(["-map", "[outv]", "-map", "1:a"])
    
    # Encoding Options
    # Use software encoding by default to avoid compatibility issues
    ffmpeg_cmd.extend(["-c:v", "libx264", "-preset", "medium", "-crf", "23"])
    ffmpeg_cmd.extend(["-c:a", "aac", "-b:a", "192k"])
    
    # Duration limit
    if preview_mode:
        ffmpeg_cmd.extend(["-t", "10"])
    else:
        ffmpeg_cmd.extend(["-shortest"])
        
    ffmpeg_cmd.append(str(output_path))
    
    # Log the command for debugging
    cmd_str = ' '.join(ffmpeg_cmd)
    logger.info(f"Running FFmpeg: {cmd_str}")
    print(f"DEBUG COMMAND: {cmd_str}") # Print to stdout for easier debugging
    print(f"DEBUG FILTER_COMPLEX: {full_filter}") # Print the filter complex separately

    process = subprocess.run(ffmpeg_cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    
    if process.returncode != 0:
        logger.error(f"FFmpeg Error: {process.stderr.decode()}")
        raise HTTPException(status_code=500, detail=f"Rendering failed: {process.stderr.decode()}")
        
    return FileResponse(output_path)

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
